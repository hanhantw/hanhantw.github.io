[ { "title": "Leetcode - 79. Word Search", "url": "/posts/Leetcode-79/", "categories": "Python, Leetcode", "tags": "leetcode", "date": "2021-10-08 14:10:00 +0800", "snippet": "Strategy: (Using Backtracking) Check the word from each cell. From each cell, we continue to check the rest word string for four directions if the cell matches the first char of the word recursively. Since we didn’t record the coming direction, we mark the coming cell as ‘#’ and recover it after finishing the iteration. If the rest word string is empty, meams we found the word matched so return ture. If the row or column is out of boundary or the cell does not match the char we’re checking, return false. Solutionclass Solution: def exist(self, board: List[List[str]], word: str) -&amp;gt; bool: rows = len(board) cols = len(board[0]) def backtracking(row, col, suffix): # end condition 1: find all matches if len(suffix) == 0: return True # end condition 2: out of boundaries or not matched if row &amp;lt; 0 or col &amp;lt;0 or row == rows or col == cols or board[row][col] != suffix[0]: return False board[row][col] = &#39;#&#39; for x, y in [(row, col-1), (row, col+1), (row-1, col), (row+1, col)]: if backtracking(x, y, suffix[1:]): return True board[row][col] = suffix[0] return False for row in range(rows): for col in range(cols): # check word from each cell if backtracking(row, col, word): return True return FalseComplexity Time Space References Question" }, { "title": "Leetcode - 56. Merge Intervals", "url": "/posts/Leetcode-56/", "categories": "Python, Leetcode", "tags": "leetcode", "date": "2021-10-04 14:10:00 +0800", "snippet": "Strategy sort the intervals by the start value. a list result to save merged intervals and the default value is the first item of the intervals iterate through the intervals and see if the current interval should be merge with the previous interval in the result by the following rules: if the current interval begins after the previous interval, then they don’t overlap, so we can appen the current interval into result; otherwise, we update the end value of the previous interval if it is smaller than the end value of current interval. Solutionclass Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) # O(nlogn) result = [intervals[0]] for start, end in intervals: start0 = result[-1][0] end0 = result[-1][1] # no overlap if end0 &amp;lt; start: result.append([start, end]) else: # has overlap result[-1][1] = max(end0, end) return resultReferences Question" }, { "title": "How to test CI/CD on GCP image", "url": "/posts/test-CICD-on-GCP/", "categories": "DevOps, CI/CD", "tags": "ci/cd", "date": "2021-10-01 14:10:00 +0800", "snippet": "Steps Run image google/cloud-sdk. In order to run docker command inside the container, we bind the host’s Docker socket instead of using dind.$ docker run -v /var/run/docker.sock:/var/run/docker.sock -it google/cloud-sdk Then, you may run your CI/CD script in the container. Authorizing access to GCP$ echo &quot;$GCLOUD_SERVICE_KEY&quot; &amp;gt; ~/gcloud-service-key.json$ gcloud auth activate-service-account --key-file ~/gcloud-service-key.json$ gcloud auth configure-docker -q" }, { "title": "Leetcode - 5. Longest Palindromic Substring", "url": "/posts/Leetcode-5/", "categories": "Python, Leetcode", "tags": "leetcode", "date": "2021-09-30 14:10:00 +0800", "snippet": "AlgorithmI. Brute force: it costs o(n^2) time to compute all substrings and o(n) time to varify if it is a palindrome. Therefore, the time complexity would be o(n^3) (pronounce as n cube).II. Dynamic programming: it would reduce time complexity to o(n^2) but increases space complexity to o(n^2) since it uses o(n^2) space to store the table.III. Expanding around center: since there are only 2n-1 palindrome centers, including one center like aba and two centers like abba, we could solve it in o(n^2) time using constant space.1.Solutionclass Solution: def longestPalindrome(self, s: str) -&amp;gt; str: n = len(s) result = &#39;&#39; for i in range(n): # one center start, end = i, i while start &amp;gt;= 0 and end &amp;lt; n and s[start] == s[end]: if (end - start + 1) &amp;gt; len(result): result = s[start:end + 1] start -= 1 end += 1 # two centers start, end = i, i + 1 while start &amp;gt;= 0 and end &amp;lt; n and s[start] == s[end]: if (end - start + 1) &amp;gt; len(result): result = s[start:end + 1] start -= 1 end += 1 return resultComplexity Time: O(n^2) Space: O(1) References Question" }, { "title": "Leetcode - 2. Add Two Numbers", "url": "/posts/Leetcode-2/", "categories": "Python, Leetcode", "tags": "leetcode", "date": "2021-09-28 14:10:00 +0800", "snippet": "Algorithm loop through the list until finish. 1.1 while looping add each value of two nodesSolution# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: head1, head2 = l1, l2 dummyHead = ListNode(0) curr = dummyHead carry = 0 while head1 or head2: p = q = 0 if head1: p = head1.val if head2: q = head2.val num = p + q + carry carry = num // 10 dummyHead.next = ListNode(num % 10) dummyHead = dummyHead.next if head1: head1 = head1.next if head2: head2 = head2.next if carry: dummyHead.next = ListNode(carry) return curr.nextComplexity" }, { "title": "Leetcode - 509. Fibonacci Number", "url": "/posts/Leetcode-509/", "categories": "Python, Leetcode", "tags": "leetcode", "date": "2021-09-24 14:10:00 +0800", "snippet": "Algorithm Recursive Set the end condition, which are fib(0) = 0 and fib(1) = 1 call the function fib recursively. Dynamic programmingTo adviod compute same fib number for many times, as the pic shown above, we may use dynamic programming. create a reference map to store the fib number that we’ve calculted assagin the default value, which fib(0) = 0 and fib(1) = 1 caculate all the resulte starting from 2 until n Solution# Recursiveclass Solution: def fib(self, n: int) -&amp;gt; int: if n == 0: return 0 if n == 1: return 1 return self.fib(n-1) + self.fib(n-2)# Dynamic programmingclass Solution: def fib(self, n: int) -&amp;gt; int: fib_map = [0] * (n + 1) if n else [0] * 2 fib_map[0] = 0 fib_map[1] = 1 for i in range(2, n + 1): fib_map[i] = fib_map[i - 2] + fib_map[i - 1] return fib_map[n]class Solution2: def fib(self, n: int) -&amp;gt; int: if n &amp;lt; 2: return n prev1 = 0 prev2 = 1 curr = 0 for i in range(2, n + 1): curr = prev1 + prev2 prev1 = prev2 prev2 = curr return resultComplexity Recursive Time: O(2^n). From the gragh shown below, we can know that as the depth aprroaches to n, time complexity grows exponatially. source from leetcode Space: O(n). Stack is used to keep track on calling the funtion fib. Dynamic Programming Time: O(n). This approach reduces time complexity to O(n) because we only compute the value from 2 to n, one time for each number. Space: O(n). We need a map length as big as the input n to store the outcome. Dynamic Programming 2 Time: O(n) Space: O(1). Since we use 3 variables to store the computed values, this reduce space to O(1). " }, { "title": "Leetcode - 704. Binary Search", "url": "/posts/Leetcode-704/", "categories": "Python, Leetcode", "tags": "leetcode", "date": "2021-09-14 14:10:00 +0800", "snippet": "Algorithm***input array must be sorted find the middle element if the target is bigger than the middle element, search the right half of the array if the target is smaller than the middle element, search the left half of the array if the target equals to the middle element, then we find the target in the array if the search ends with left pointer and right pointer at the same position, and it is also not the target, then the target is not in the array Solutionclass Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: lo, hi = 0, len(nums) - 1 while hi &amp;gt;= lo: mid = lo + (hi - lo) // 2 if target &amp;gt; nums[mid]: lo = mid + 1 elif target &amp;lt; nums[mid]: hi = mid - 1 else: return mid return -1Complexity Time: O(logn) Space: O(1) References Why calculate middle value in that way? Question " }, { "title": "Python 專案環境設定", "url": "/posts/Python-Enviroment/", "categories": "Python, Environment", "tags": "pyenv", "date": "2021-09-09 14:10:00 +0800", "snippet": "Introduction(待補)Objectives結束之後知道如何設定環境實作" }, { "title": "uWSGI v.s. Gunicorn in Python", "url": "/posts/uWSGI&Gunicorn/", "categories": "Python, Framework", "tags": "flask", "date": "2021-09-08 14:10:00 +0800", "snippet": "Introduction (待補) what is WSGI? What are the differences between uWSGI and Gunicorn? Objectives 查看 uWSGI 及 Gunicorn 如何呈現實作環境設定$ pip install flask uwsgi gunicornpython file建立 main.py 檔案，這邊用不用 flask 都可以 using Flaskfrom flask import Flaskapp = Flask(__name__)app.debug = True@app.route(&#39;/&#39;)def hello(): return &#39;Hello, World!&#39;if __name__ == &quot;__main__&quot;: app.run(debug=True) w/o Flaskdef app(environ, start_response): data = &quot;Hello, World!&quot; start_response(&quot;200 OK&quot;, [ (&quot;Content-Type&quot;, &quot;text/plain&quot;), (&quot;Content-Length&quot;, str(len(data))) ]) return iter([data])uWSGI因為是在本機運行，所以我們使用--http-socket即可，如果是還有一層 web server (如 nginx)，則要用--socket。以下是分別運行1個 worker 、3個 worker、3個 worker w/ 4 threads 的結果，跑完之後可以用指令ps看一下 one worker$ uwsgi --http-socket 0.0.0.0:5000 -w main:app one master with 3 workers$ uwsgi --http-socket 0.0.0.0:5000 -w main:app --master --workers 3$ uwsgi --http-socket 0.0.0.0:5000 -w main:app --master --workers 3 --threads 4可以看到 process 一樣只有4個(1 master, 3 workers)但每個 process 底下各有4個 threadsGunicorn$ gunicorn -b :8787 -w 4 --threads 3 main:app可以看到 gunicorn 會自動多產生一個 process 當 master若有設定 thread 數量，則會顯示Using worker: gthread，不然一般為Using worker: syncReferences uWSGI Options uWSGI和Gunicorn对比实践笔记 QA: uwsgi invalid request block size Gunicorn Settings " }, { "title": "Leetcode - 207", "url": "/posts/Leetcode-207/", "categories": "Python, Leetcode", "tags": "leetcode", "date": "2021-09-06 14:10:00 +0800", "snippet": "Algorithm loop the course list and make a list for its relationship that we can know which course is a prerequisite for what other courses, like [[1, 2], [3], [3], []] use a list to mark each node’s status. -1: not visited, 0: visiting, 1: finishing visited. do depth-first search until finiish visiting all nodes. if we found no cycle, that means we can finish all courses, so we will return true. Otherwise, return false. Solutionclass Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; bool: def dfs(vertex: int) -&amp;gt; bool: if status[vertex] &amp;gt; 0: # finish visiting return False status[vertex] = 0 for child in graph[vertex]: if not dfs(child): return False status[vertex] = 1 return True graph = defaultdict(list) status = [-1] * numCourses for c1, c0 in prerequisites: graph[c0].append(c1) for vertex in range(numCourses): if not dfs(vertex): return False return TrueComplexity Time Space References Question" } ]
